<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on zsh&#39;blog</title>
    <link>https://ursasi.github.io/post/</link>
    <description>Recent content in Posts on zsh&#39;blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 16 Oct 2023 20:10:29 +0800</lastBuildDate><atom:link href="https://ursasi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于Raft</title>
      <link>https://ursasi.github.io/post/%E5%85%B3%E4%BA%8Eraft/</link>
      <pubDate>Mon, 16 Oct 2023 20:10:29 +0800</pubDate>
      
      <guid>https://ursasi.github.io/post/%E5%85%B3%E4%BA%8Eraft/</guid>
      <description>聊聊关于Raft与分布式系统的一些思考
Raft出现的背景 为了解决的问题 如何解决 是什么，不是什么 对比前者 单主节点存在的问题 MapReduce、GFS、Replication-backup
Raft如何解决 Raft 的选举 其他的选举算法与策略 ZAB Bully Raft 的日志复制 Raft 的成员变更 Raft in Everything Redis etcd TiDB 容灾 分布式共识算法与区块链 </description>
    </item>
    
    <item>
      <title>谈谈锁的五大问题与AQS</title>
      <link>https://ursasi.github.io/post/%E8%B0%88%E8%B0%88%E9%94%81%E7%9A%84%E4%BA%94%E5%A4%A7%E9%97%AE%E9%A2%98%E4%B8%8Eaqs/</link>
      <pubDate>Fri, 13 Oct 2023 12:24:54 +0800</pubDate>
      
      <guid>https://ursasi.github.io/post/%E8%B0%88%E8%B0%88%E9%94%81%E7%9A%84%E4%BA%94%E5%A4%A7%E9%97%AE%E9%A2%98%E4%B8%8Eaqs/</guid>
      <description>现代操作系统为程序提供了多种多样的简单易用的锁操作，方便程序开发者利用它们进行并发控制。然而，这种抽象在的提高设计语言灵活性的同时屏蔽了底层设计，不同语言的设计思路往往不同，了解它们的异同有利于理解并发模型，将其更好地运用在并发编程中，避免一叶障目，不见泰山。
每种语言对于锁的抽象程度不同，采用的锁模型与相应的机制也不尽相同，导致关于锁的概念众多，纷繁复杂。本文将锁的设计总结为五大问题，分别是锁表示问题、获取/释放问题、阻塞挂起问题、阻塞唤醒问题、线程存储问题。搞清楚五大问题有利于理解锁设计的相关思想。最后本文将会以Go、Java的锁模型举例分析它们的异同，且着重梳理Java中AQS的设计方法与理念。
问题之间的关系 总体来讲，五大问题关系到锁本身的存在（表示问题）、锁如何获取/释放、阻塞的时候如何挂起、释放的时候如何唤醒线程、线程存放在哪里。这些问题本身按照线程与锁的生命周期息息相关，按照顺序，它们的关系如下图所示。
锁表示 获取与释放 获取 释放 阻塞 挂起 唤醒 线程存储 </description>
    </item>
    
    <item>
      <title>校园网环境连接机房、实验室网盘、执行打印任务</title>
      <link>https://ursasi.github.io/post/%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%8E%AF%E5%A2%83%E8%BF%9E%E6%8E%A5%E6%9C%BA%E6%88%BF%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%BD%91%E7%9B%98%E6%89%A7%E8%A1%8C%E6%89%93%E5%8D%B0%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Thu, 12 Oct 2023 10:22:48 +0800</pubDate>
      
      <guid>https://ursasi.github.io/post/%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%8E%AF%E5%A2%83%E8%BF%9E%E6%8E%A5%E6%9C%BA%E6%88%BF%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%BD%91%E7%9B%98%E6%89%A7%E8%A1%8C%E6%89%93%E5%8D%B0%E4%BB%BB%E5%8A%A1/</guid>
      <description>本说明针对于整个校园网环境。
如果没有全校园网环境内连接需求，仅仅在实验室连接机房、网盘、打印机，无需以下配置。
前提条件 连接 WiFi：SSID：nuaa.wifi6/nuaawifi-2.4g 进行统一身份认证。
安装 WireGuard WireGuard 是一种现代、高性能的虚拟专用网络协议。它旨在提供简单、安全、高效的网络连接，适用于各种操作系统和设备。
WireGuard 提供多种终端安装程序
官方地址 ：https://www.wireguard.com/install/
包含但不限于 Windows、MacOS、Android、iOS、Ubuntu。
Windows、Android 常见Windows、Android安装包已经放置于 DSM/Share/WireGuard/install 文件夹下
macOS、iOS MacOS、iOS 需要外区 Apple 账号登录 App Store
目前可用的外区 Apple 账号如下：
TODO：外区账号搜集
配置 WireGuard 已经为部分实验室成员生成对应的了 WireGuard 的配置文件，其放置于DSM/Share/WireGuard/config，格式为 周杰伦-NUAA.conf 还没有配置文件的成员如有需要可以请求生成。
Windows macOS Android iOS 连接机房 第一次连接机房机器需要启动虚拟机，联系网管开启。
Windows macOS 连接实验室打印机 连接方式与在实验室环境下连接打印机方式类似，但添加打印纸需要通过IP添加。
Windows macOS Android iOS 连接实验室网盘 连接方式与在实验室环境下连接网盘方式类似，但需要通过IP进行添加。
为方便管理，请在网盘中以姓名拼音首字母缩写创建个人文件夹，例如周杰伦→ZJL 所有文件夹均无权限管理，切勿存放私密文件 Windows macOS Android iOS </description>
    </item>
    
    <item>
      <title>Git 相关规范</title>
      <link>https://ursasi.github.io/post/git%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Wed, 11 Oct 2023 21:25:22 +0800</pubDate>
      
      <guid>https://ursasi.github.io/post/git%E7%9B%B8%E5%85%B3/</guid>
      <description>Git 相关 Commit 一个好的 Commit Message 规范可以使 Commit Message 的可读性更好，并且可以实现自动化。那究竟如何写一个易读的 Commit Message 呢？
在 Angular 规范中，Commit Message 包含三个部分，分别是 Header、Body 和 Footer， 格式如下：
其中，Header 是必需的， Body 和 Footer 可以省略。在以上规范中，必须用括号（）括起来， ［］后必须紧跟冒号，冒号后必须紧跟空格，2个空行也是必需的。
Header Header 部分只有一行，包括三个字段：type（必选）、scope（可选）和 subject（必选）。
type是用来说明commit 的类型。为了方便记忆，我把这些类型做了归纳，它们主要可以归为 Development 和 Production 共两类。它们的含义是：
Development：这类修改一般是项目管理类的变更，不会影响最终用户和生产环境的代码，比如 CI 流程、构建方式等的修改。遇到这类修改，通常也意味着可以免测发布。 Production：这类修改会影响最终的用户和生产环境的代码。所以对于这种改动，我们一定要慎重，并在提交前做好充分的测试。 以下列出一些常用的type、类别，在提交的时候请务必注意
feat: Production 新增功能 fix: Production Bug 修复 docs: Development 文档更新 chore: Development 构建流程、辅助工具 Body Body 部分可以分成多行，而且格式也比较自由。不过，和 Header 里的一样，它也要以动词开头，使用现在时。此外，它还必须要包括修改的动机，以及和跟上一版本相比的改动点。
Footer Footer 部分不是必选的，可以根据需要来选择，主要用来说明本次 commit 导致的后果。在实际应用中，Footer 通常用来说明不兼容的改动和关闭的Issue 列表。
未完 </description>
    </item>
    
  </channel>
</rss>
